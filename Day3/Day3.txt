MY NOTES FROM SIC ---> BY NITHIN SIR on PYTHON FUNDAMENTALS , DATA ANALYTICS , DSA
-------------> Day3: 13/08/25 

command line arguments:
#cla_info.py
import sys

print(sys.argv) # printing the argv list
print(type(sys.argv)) # printing type of argv
print(sys.argv[0]) # printing 1st element in the list argv
print(sys.argv[1]) # printing 2nd element in the list argv
print(type(sys.argv[0]))
print(type(sys.argv[1]))
print(sys.argv[2]) # printing 3rd element in the list argv

in cmd : python cla_info.py 15 ; this command is considered as string input in argv [].
argv[]: it is a array/List containing the command line arguments "cla" as a "string" in it. 
cla contains the file name as 1st element and 15 as 2nd element.
--------------------------------------------------------------------------------------------------------

** Formatting :
 
ex----> print("%d * %2d = %3d " %(n,i,n*i))
ex----> print("%d * %02d = %03d " %(n,i,n*i))

--------------------------------------------------------------------------------------------------------
range function in Python:

range(10)
Start from 0 (default start value) and end with 9 (one before 10)

range(2, 10)
Start from 1 (user given start value) and end with 9 (one before 10)

range(2, 100, 5)
Start from 2 (user given start value) and end with 99 (one before 100) with user given increment/step of +5

range(90, 10, -4)
Start from 90 (user given start value) and end with 9 (one before 10) with user given increment of -4 (or decrement of +4)

Correct way to call range, but no o/p:
range(10, 10)
range(0)
range(20, 5)

Incorrect way of calling range: (We get exception)
range()
range(10, 20, 'abc')
range('abc')

--------------------------------------------------------------------------------------------------------------
----> *Var_args :
                 stores variable length argument 
				 it is a tuple that stores string arguments
				 *---> is not a pointer , it can take any no. of arguments.
I/P:
def my_range(*var_args):
    print(var_args)
    print(type(var_args))
    print(var_args[0])
    print(type(var_args[0]))

1.#my_range(0)
2.#my_range()
3.#my_range(1, 2, 3)
4.#my_range('a', 'bnm', 'gsss', 'gsssietw')

O/P:
1. (0,)
<class 'tuple'>
0
<class 'int'>
2. my_range()
 line 4, in my_range
    print(var_args[0])
          ~~~~~~~~^^^
IndexError: tuple index out of range
3. (1, 2, 3)
<class 'tuple'>
1
<class 'int'>
4.('a', 'bnm', 'gsss', 'gsssietw')
<class 'tuple'>
a
<class 'str'>

----------------------------------------------------------------------------------------------------------------

1.Functions : they are called without objects.
2.Methods : they are called with objects.
3.Map:it is a keyword to access elements one by one into lists.
numbers = (1, 4, 6, 9)
numbers = list(map(int, sys.argv[1:]))
          
		  [OR]

numbers = list(sys.argv[1:])
nums = []
for i in range(len(numbers)):
    nums.append(int(numbers[i]))
4.Yeilds : 
*yield is like return, but instead of ending the function, it pauses it.
*When the function is called again, it resumes from where it left off.
*A function that has yield is called a generator function.
ex: I/P: def numbers(n):                                                   [OR] Using return I/P: def numbers(n):
            for i in range(1, n+1):                                                                         result = []
                 yield i   # pauses after returning i                                                                     for i in range(1, n+1):
            for num in numbers(5):                                                                             result.append(i)
                print(num)                                                                         return result

                                                                                     print(numbers(5))
O/P: 
1
2
3
4
5

Generators are useful when:
* You donâ€™t want to store all values in memory at once.
* You want to generate values one by one (on demand).
-----------------------------------------------------------------------------------------------------------------------------------------------------
Error/Exemption Handling: 
def my_function(): thowrs PqrError, LmnError
try:
    for number in sys.argv[1:]:
        for element in number:
            if not (element >= '0' and element <= '9'):
                print(f'Invalid input {number}')
                sys.exit('Program ended')
except AbcError:
    pass
except XyzError:
    pass

Keywords in Exception Handling:
try
except
throws
raise
classes: Exception, ValueError, TypeError etc.
-----------------------------------------------------------
   1.try and except:
  ------------------
Used for handling exceptions (errors).
Code inside try is executed first.
If an error occurs, Python jumps to the matching except block.

Example:
try:
    num = int(input("Enter a number: "))  # may cause ValueError
    print("You entered:", num)
except ValueError:
    print("Invalid input! Please enter a number.")
------------------------------------------------------------------------------------------
	2. raise:
   ------------
Used to manually raise an exception when a condition is not met.
You can raise built-in exceptions or create custom ones. 

Example:
def divide(a, b):
    if b == 0:
        raise ZeroDivisionError("You cannot divide by zero!")  # manually raise
    return a / b

try:
    print(divide(10, 0))
except ZeroDivisionError as e:
    print("Error:", e)
------------------------------------------------------------------------------------------
ðŸ”¹ 1. Generalised Error Classes
These are the built-in base exception classes that cover a wide range of errors.
They are â€œgeneralâ€ because many specific errors inherit from them.

Examples:
Exception â†’ The base class for almost all errors.
ArithmeticError â†’ Base class for math-related errors.
try:
    x = 10 / 0   # ZeroDivisionError (specialised)
except Exception as e:   # generalised handler
    print("Caught a general error:", type(e).__name__)

ðŸ”¹ 2. Specialised Error Classes
These are specific error classes that inherit from generalised ones.
They represent particular types of errors.

Examples:
ZeroDivisionError (child of ArithmeticError)
IndexError (child of LookupError)
try:
    my_list = [1, 2, 3]
    print(my_list[5])   # IndexError
except IndexError:   # specialised handler
    print("List index out of range!")
---------------------------------------------------------------------------------------------------------